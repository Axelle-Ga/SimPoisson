package proj;

import java.awt.Point;
import java.util.ArrayList;
import java.util.List;

public class Sardine extends Poisson {
	
	private int largeur;
	private int longueur;
	protected boolean dangeureux = false;	

	
	protected double visionPoisson = 20;//rayon du cercle pour la comparaison avec les autres poissons pour ne pas les toucher



	public Sardine(int x, int y, double or, int largeur ,int longueur) {
		super(x,y,or);		
		this.largeur=7;
		this.longueur=2;
		avancer();
	}
/////////////////////////////////////////////////////////////////	
//Spécial pour que les sardines soient mangées
	protected boolean etreMange(List<Predateur> predateurs) {
		for (int i=0; i<predateurs.size();i++) {
			if (Point.distance(predateurs.get(i).position[0],predateurs.get(i).position[1], this.position[0], this.position[1])<rayoninf) {
				return true;	
			}
		}
		return false;
	}
////////////////////////////////////////////////////////////////


// INTERRACTION AVEC LES BANCS DE POISSONS ET LES AUTRES OBSTACLES

	// CHANGEMENT DE DIRECTION PAR RAPPORT AUX OBJETS AUTOUR
	
		//Retourne le vecteur pour s'aligner
		protected double[] vecteurAligner(List<Sardine> listSardine) {
			/*Fonctionne, mais les poissons finissent par aller en bas à droite -> comprendre pourquoi*/
			double[] vecteurAligne = {0, 0};
			List<Sardine> sardinePercu = poissonsPercus(listSardine, this.rayoninf, this.rayonMed);	//On récupère tous les poissons perçus par le poisson
			if (sardinePercu.isEmpty()) {
				return(vecteurAligne);	//Si il n'y a pas de poissons perçus on renvoie le vecteur {0,0}
				}
			int nbrPoissonProche = 0;		//On initialise un compteur de poisson
			double somme_orientation = 0;	//On initialise la somme des orientations
			for( Poisson i : sardinePercu) {
				somme_orientation += i.orientation;		//On somme les orientattion des poissons perçue
				nbrPoissonProche += 1;
				}
			double moyenne_orientation = somme_orientation/nbrPoissonProche;	//On calcule la moyenne
			vecteurAligne[0] = Math.sin(moyenne_orientation);	//On calcul le vecteur que doit suivre le poisson pour s'aligner
			vecteurAligne[1] = Math.cos(moyenne_orientation);
			return(normerVecteur(vecteurAligne));
		}
		
		//Retourne le vecteur pour se rapprocher de la position moyenne
		protected double[]  vecteurRapprocherMoy(List<Sardine> listSardine) {
			List<Sardine> poissonSardine = poissonsPercus(listSardine, this.rayonMed, this.rayonsup);	//On récupère tous les poissons perçus par le poisson
			double[] vecteurRapproche = {0, 0};
			if (poissonSardine.isEmpty()) {
				return(vecteurRapproche);	//Si il n'y a pas de poissons perçu on renvoie {0,0}
			}
			double somme_x = 0;	//On initialise la somme des possition en x
			double somme_y = 0;	//On initialise la somme des possition en y
			double nbPoisson = 0;	//On initialise un compteur
			for (Poisson i : poissonSardine) {
				somme_x += i.position[0];	//On parcourt la liste des poissons pour calculer les 2 sommes
				somme_y += i.position[1];
				nbPoisson += 1;
			}
			double moy_x = somme_x/nbPoisson;	//On calcul la moyenne en x
			double moy_y = somme_y/nbPoisson;	//On calcul la moyenne en y
			vecteurRapproche[0]=moy_x-this.position[0];	//On calcul le vecteur vitesse pour se rapprocher de la position moyenne
			vecteurRapproche[1]=moy_y-this.position[1];
			return(normerVecteur(vecteurRapproche));
		}
		
		// Retourne le vecteur d'eloigner
		protected double[] vecteurEloigner(List<Sardine> listSardine) {
			List<Sardine> poissonPercu = poissonsPercus(listSardine, 0, this.rayoninf);	//On récupère tous les poissons perçus par le poisson
			double[] vecteurEloigne = {0, 0};
			if (poissonPercu.isEmpty()) {
				return(vecteurEloigne);		//Si il n'a a pas de poissons perçus on renvoie {0,0}
			}
			double somme_vitX_away = 0;	//On initialise à 0 la somme des vitesses en x
			double somme_vitY_away = 0;	//On initialise à 0 la somme des vitesses en y
			double nb_poisson=0;		//On initialise un compteur
			for( Poisson i : poissonPercu) {
				somme_vitX_away += -(i.position[0]- position[0]);	//On calcul les sommes
				somme_vitY_away +=-(i.position[1]- position[1]);
				nb_poisson +=1;
			}
			vecteurEloigne[0] = somme_vitX_away/nb_poisson; 	// moyenne des vitesses en x pour s'éloigner
			vecteurEloigne[1] = somme_vitY_away/nb_poisson;		// moyenne des vitesses en x pour s'éloigner
			return(normerVecteur(vecteurEloigne));	
		}	
		
		
		
	
	// CHOIX SUR LE POIDS DES ACTIONS
	
		protected void decision(List<Obstacle> o, List<Sardine> p, List<Predateur> predateur) {//Fonction qui permet de faire tous les déplacements (moyenne) peut être changé
		
			//On définit les coeff pour le vecteur vitesse final
			double coef_Rapproche = 0.5;
			double coeff_Aligne = 0.4;
			double coeff_Eloigne = 0.5;
			double coeff_Evite = 0.8;
			
			//On récupère les differents vecteurs vitesses
			double[] vitSeRapproche = vecteurRapprocherMoy(p);
			double[] vitSeloigne = vecteurEloigner(p);
			double[] vitSaligne = vecteurAligner(p);
			double[] vitEvite = vecteurEviter2(o);
			double[] vitEvitePredateur = vecteurEvitePredateur(predateur);
			
			//Si le poisson est dans l'obstacle il rebondi radicalement  
			//Pas besoin entre sardines et predateurs car le poisson est mangé
			if(vitEvite[0]==-this.vitesse[0] && vitEvite[1]==-this.vitesse[1]) {
				orienter(-this.vitesse[0],-this.vitesse[1]);
				normaliseVitesse();
			}
			
			//On definit le nouveau vecteur vitesse comme la somme des différents vecteurs vitesse
			double[] vitNouvelle = new double[2];
			vitNouvelle[0] = coef_Rapproche*vitSeRapproche[0]+coeff_Eloigne*vitSeloigne[0]+coeff_Aligne*vitSaligne[0]+coeff_Evite*(vitEvite[0]+vitEvitePredateur[0]);
			vitNouvelle[1] = coef_Rapproche*vitSeRapproche[1]+coeff_Eloigne*vitSeloigne[1]+coeff_Aligne*vitSaligne[1]+coeff_Evite*(vitEvite[1]+vitEvitePredateur[1]);		
			
			//On calcul la norme de vecteur
			double normeVect =Math.sqrt(Math.pow(vitNouvelle[0], 2)+Math.pow(vitNouvelle[1], 2));
			
			//Si la norme et nulle le poisson continu d'avancer
			if( normeVect==0.0) {
				orienter(this.vitesse);
				normaliseVitesse();
			}
			else{
				//on rajoute la nouveau vecteur vitesse à celui du poisson
				vitNouvelle[0]= this.vitesse[0] +vitNouvelle[0];
				vitNouvelle[1]= this.vitesse[1] +vitNouvelle[1];
				orienter(vitNouvelle);
				
				//Et on le norme
				normaliseVitesse();
			}
		}
}
