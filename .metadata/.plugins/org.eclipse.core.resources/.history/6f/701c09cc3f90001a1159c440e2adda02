package proj;

import java.awt.Point;
import java.util.ArrayList;
import java.util.List;

public class Predateur extends Poisson{
	
	protected int largeur;
	protected int longueur;
	protected boolean dangeureux = true;	



	
	public Predateur(int x, int y, double or, int largeur , int longueur) {
		super(x,y,or);		
		this.largeur=largeur;
		this.longueur=longueur;
		}
	
// INTERRACTION AVEC LES BANCS DE POISSONS ET LES AUTRES OBSTACLES

	// CHANGEMENT DE DIRECTION PAR RAPPORT AUX OBJETS AUTOUR
	
		protected double[] vecteurSuivre(List<Sardine> listSardine) {
			/*Fonctionne, mais les poissons finissent par aller en bas à droite -> comprendre pourquoi*/
			double[] vecteurSuivre = {0, 0};
			List<Sardine> poissonPercu = poissonsPercus(listSardine, this.rayoninf, this.rayonMed);	//On récupère tous les poissons perçus par le predateur
			if (poissonPercu.isEmpty()) {
				return(vecteurSuivre);	//Si il n'y a pas de poissons perçus on renvoie le vecteur {0,0}
				}
			int nbrPoissonProche = 0;		//On initialise un compteur de poisson
			int somme_X = 0;	//On initialise la somme des positions en x
			int somme_Y = 0;	//On initialise la somme des positions en x

			for( Poisson i : poissonPercu) {
				somme_X += i.position[0];		
				somme_Y += i.position[1];		
				nbrPoissonProche += 1;
				}
			int moyenne_X = somme_X/nbrPoissonProche;	//On calcule la moyenne en X et en Y
			int moyenne_Y = somme_Y/nbrPoissonProche;
			
			vecteurSuivre[0] = moyenne_X - this.position[0];	//On calcul le vecteur que doit suivre le poisson pour s'aligner
			vecteurSuivre[1] = moyenne_Y - this.position[1];	// On divise par t = 1 pour être homogène
			return(normerVecteur(vecteurSuivre));
		}
	

	// CHOIX SUR LE POIDS DES ACTIONS
	
		protected void decision(List<Obstacle> o, List<Sardine> p, List<Predateur> predateur) {//Fonction qui permet de faire tous les déplacements (moyenne) peut être changé
				
				//On définit les coeff pour le vecteur vitesse final
				double coeff_Suivre = 0.5;
				double coeff_Evite = 0.9;
				
				//On récupère les differents vecteurs vitesses
				double[] vitSuivre = vecteurSuivre(p);
				double[] vitEvite = vecteurEviter2(o);
				double[] vitEvitePredateur = vecteurEvitePredateur(predateur);

				
				//Si le requin est dans l'obstacle ou dans autre requin il rebondi radicalement
				if((vitEvite[0]==-this.vitesse[0] && vitEvite[1]==-this.vitesse[1]) || (vitEvitePredateur[0]==-this.vitesse[0] && vitEvitePredateur[1]==-this.vitesse[1])) {
					orienter(-this.vitesse[0],-this.vitesse[1]);
					normaliseVitesse();
				}
				
				//On definit le nouveau vecteur vitesse comme la somme des différents vecteurs vitesse
				double[] vitNouvelle = new double[2];
				vitNouvelle[0] = coeff_Suivre*vitSuivre[0]+coeff_Evite*(vitEvite[0]+vitEvitePredateur[0]);
				vitNouvelle[1] = coeff_Suivre*vitSuivre[1]+coeff_Evite*(vitEvite[1]+vitEvitePredateur[1]);
				
				//On calcul la norme de vecteur
				double normeVect =Math.sqrt(Math.pow(vitNouvelle[0], 2)+Math.pow(vitNouvelle[1], 2));
				
				//Si la norme et nulle le poisson continu d'avancer
				if( normeVect==0.0) {
					orienter(this.vitesse);
					normaliseVitesse();
				}
				else{
					//on rajoute la nouveau vecteur vitesse à celui du poisson
					vitNouvelle[0]= this.vitesse[0] +vitNouvelle[0];
					vitNouvelle[1]= this.vitesse[1] +vitNouvelle[1];
					orienter(vitNouvelle);
					
					//Et on le norme
					normaliseVitesse();
				}
		}

}
