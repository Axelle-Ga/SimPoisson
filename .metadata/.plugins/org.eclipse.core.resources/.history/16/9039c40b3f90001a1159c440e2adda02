package proj;

import java.awt.Point;
import java.util.ArrayList;
import java.util.List;

abstract class Poisson {
	
	protected int[] position;
	protected double[] vitesse;
	protected double orientation;
//	private int largeur;
//	private int longueur;

	protected double rayoninf = 20;
	protected double rayonMed = 50;
	protected double rayonsup = 80;
	protected double angleMax = Math.PI/4; //angle en radian
	
	protected double Vnorm=10;
	protected double angleDePerception = Math.toRadians(165); //angle moitié du champ de vision
	protected Obstacle obsPlusProche;

	
	
//	public Poisson (int x , int y , double or , int largeur , int longueur) {
	public Poisson (int x , int y , double or) {

		this.position = new int[2];
		this.position[0] = x % 750;
		this.position[1] = y % 750;
		this.orientation = Math.toRadians(or);
		
		this.vitesse = new double[2];
		this.vitesse[0] = Math.sin(orientation);
		this.vitesse[1] = Math.cos(orientation);
		this.normaliseVitesse();
		
//		this.largeur = largeur;
//		this.longueur = longueur;
		
	}
	
	
	
// NORMALISATION ET ORIENTATION
	//Normalise le vecteur vitesse
	protected void normaliseVitesse() {
		double nv = this.normVit();
		this.vitesse[0] = this.vitesse[0]/nv; 
		this.vitesse[1] = this.vitesse[1]/nv;
	}
	
	//Recupère la norm du vecteur vitesse
	protected double normVit() {
		
		double norm = Math.sqrt(Math.pow(this.vitesse[0], 2) + Math.pow(this.vitesse[1],2));
		return(norm);
	}
	
	public static double[] normerVecteur(double[] vecteur) {
		//Normalise le vecteur
		double normeVect =Math.sqrt(Math.pow(vecteur[0], 2)+Math.pow(vecteur[1], 2));
		if(normeVect == 0) {
			return(vecteur);
		}
		vecteur[0]= vecteur[0]/normeVect;
		vecteur[1]= vecteur[1]/normeVect;
		return(vecteur);
	}
	
	protected void orienter(double angle) {
		this.orientation = angle;
		this.vitesse[0] = (int)(Math.sin(this.orientation)*3);
		this.vitesse[1] = (int)(Math.cos(this.orientation)*3);
	}
	
	
	protected void orienter(double vitx,double vity) {
		
		this.vitesse[0] = vitx;
		this.vitesse[1] = vity;
		this.orientation = Math.atan2(vity,vitx);
	}
	
	
	protected void orienter(double[] vit) {
		
		this.vitesse[0] = vit[0];
		this.vitesse[1] = vit[1];
		this.orientation = Math.atan2(this.vitesse[1],this.vitesse[0]);
	}
	

// AVANCER 
	//Fait avancer le poisson
	protected void avancer() {             // t : temps entre deux positions
		this.position[0] = (int)(this.position[0] + this.vitesse[0]*Vnorm)%800 ; // On multiplie evidemment par un temps t=1
		this.position[1] = (int)(this.position[1] + this.vitesse[1]*Vnorm)%750 ;
		
		if(this.position[0]<0) {
			this.position[0] = this.position[0]+800;
		}
		
		if(this.position[1]<0) {
			this.position[1] = this.position[1]+750;
		}
	}


// PRENDRE EN COMPTE LES OBJETS AUTOUR	
	
	// VECTEURS A PRENDRE EN COMPTE POUR LA NOUVELLE DIRECTION
	
		
		
		
		protected double[] vecteurEviter2(List<Obstacle> obstacle) {
			double[] vecteurEvite = {0,0};
			List<Obstacle> ObstaclesVus = ObstaclesPercus(obstacle,0,50);
			for(Obstacle i : ObstaclesVus) {
				double dist = Point.distance(position[0], position[1], i.positionCentre[0],i.positionCentre[1]);
				double dX = position[0]-i.positionCentre[0];
				double dY = position[1]-i.positionCentre[1];
				if(dist<0) {
					vecteurEvite[0] += -this.vitesse[0];
					vecteurEvite[1] += -this.vitesse[1];
					System.out.println("poisson dans l'obstacle");
					return(vecteurEvite);
					}			
				vecteurEvite[0] += i.taille*dX;
				vecteurEvite[1] += i.taille*dY;
				}
			return(normerVecteur(vecteurEvite));
		}
		
		// Retourne le vecteur pour eviter un prédateur
		protected double[] vecteurEvitePredateur(List<Predateur> predateurs) {
			double[] vecteurEvite = {0,0};
			List<Predateur> PredateurVus = PredateurPercus(predateurs,0,50);
			for(Predateur i : PredateurVus) {
				double dist = Point.distance(position[0], position[1], i.position[0],i.position[1]);
				double dX = position[0]-i.position[0];
				double dY = position[1]-i.position[1];
				if(dist<0) {
					vecteurEvite[0] += -this.vitesse[0];
					vecteurEvite[1] += -this.vitesse[1];
					System.out.println("poisson dans l'obstacle");
					return(vecteurEvite);
				}			
				vecteurEvite[0] += i.largeur*dX;
				vecteurEvite[1] += i.largeur*dY;
			}
			return(normerVecteur(vecteurEvite));
			}
		

	
	// OBJET DANS CHAMPS DE VISION
		public List<Sardine> poissonsPercus(List<Sardine> listSardine, double rayonMin, double rayonMax){
			/*Retourne sous forme d'arraylist les poissons perçus ie les poissons dont la position
			 *  dans le cercle de centre la position du poisson étudié et de rayon : rayonMax et à 
			 *  l'éxtérieur du cercle de centre la pos du poisson étudié et de rayon : rayon min
			 *  Et qui sont dans le champ de vision
			 */
			
			//On crée un arrayList dans laquelle on va stocker les poissons perçus
			List<Sardine> Sardine = new ArrayList<>();	
			
			for (Sardine i : listSardine) {
				//On calcul la distance du poisson à l'obstacle i
				double d = Point.distance(this.position[0], this.position[1], i.position[0], i.position[1]);
				
				if (d>rayonMin && d<rayonMax && this.estDansChampsDeVision(i)==true) {
					Sardine.add(i);	//Si le poissons est dans le cercle de perception on le rajoute à l'arraylist			
				}
			}
			return(Sardine);
		}
		
		
		//Renvoie les deux angles limites du champs de vision
		protected double[] champsDeVision() {
			
			//angleDePerception correspond à la moitié de l'angle du cdv total
			
			//On renvoie les deux angles limite sous forme de tableau : {angleMin,angleMax}
			
			double[] champDeVision = new double[2];
			
			//angleMin (je prend 2 fois le modulo pour avoir une valeur positive)
			champDeVision[0] = (((this.orientation - this.angleDePerception)%(2*Math.PI))+(2*Math.PI))%(2*Math.PI);
			
			//angleMin (je prend 2 fois le modulo pour avoir une valeur positive)
			champDeVision[1] = (((this.orientation + this.angleDePerception)%(2*Math.PI))+(2*Math.PI))%(2*Math.PI);
			return(champDeVision);
			}
		
		//Renvoie si true si le poisson est dans le champs de vision, false sinon
		protected boolean estDansChampsDeVision(Poisson poisson) {
			double[] cdvision = this.champsDeVision();	//On récupère le champs de vision du poisson
			double alpha = this.angleOrigineAvecPoisson(poisson);		//On va calculer l'angle entre l'origine et la droite formée par les 2 poissons
			if (alpha>=cdvision[0] || alpha<=cdvision[1]) {	//Si le poisson est dans le cdv on retourne true sinon false
				return (true);
			}			
			return(false);
		}
		
		
		//Renvoie si true si l'obstacle est dans le champs de vision, false sinon
		protected boolean ObstacleDansChampsDeVision(Obstacle obstacle) {
			double[] cdvision = this.champsDeVision();	//On récupère le champs de vision du poisson
			double alpha = this.angleOrigineAvecObstacle(obstacle);	//angle entre l'origine et la droite formée par les 2 poissons
			if (alpha>=cdvision[0] || alpha<=cdvision[1]) {
				return (true);	//Si le poisson est dans le cdv on retourne true sinon false
			}
			return(false);
		}
		
		public List<Obstacle> ObstaclesPercus(List<Obstacle> listObstacles, double rayonMin, double rayonMax){
			/*Retourne sous forme d'arraylist les obstacles perçus ie les poissons dont la position
			 *  dans le cercle de centre la position du poisson étudié et de rayon : rayonMax et à 
			 *  l'éxtérieur du cercle de centre la pos du poisson étudié et de rayon : rayon min
			 *  Et qui sont dans le champ de vision
			 */
			
			//On crée un arrayList dans laquelle on va stocker les poissons perçus
			List<Obstacle> ObstaclesVus = new ArrayList<>();
			
			for (Obstacle i : listObstacles) {
				
				//On calcul la distance du poisson à l'obstacle i
				double dx = this.position[0]-i.positionCentre[0];
				double dy = this.position[1]-i.positionCentre[1];
				double d = (Math.sqrt(Math.pow(dx, 2)+Math.pow(dy, 2))-(i.largeur/2));
				
				
				if (d<rayonMax /*&& this.ObstacleDansChampsDeVision(i)==true*/) {
					
					//Si le poissons est dans le cercle de perception on le rajoute à l'arraylist
					ObstaclesVus.add(i);				
				}
			}
			return(ObstaclesVus);
		}
		
		public List<Predateur> PredateurPercus(List<Predateur> listPredateur, double rayonMin, double rayonMax){
			/*Retourne sous forme d'arraylist les obstacles perçus ie les poissons dont la position
			*  dans le cercle de centre la position du poisson étudié et de rayon : rayonMax et à 
			*  l'éxtérieur du cercle de centre la pos du poisson étudié et de rayon : rayon min
			*  Et qui sont dans le champ de vision
			*/
	
			//On crée un arrayList dans laquelle on va stocker les poissons perçus
			List<Predateur> PredateursVus = new ArrayList<>();
	
			for (Predateur i : listPredateur) {
	
				//On calcul la distance du poisson à l'obstacle i
				double dx = this.position[0]-i.position[0];
				double dy = this.position[1]-i.position[1];
				double d = (Math.sqrt(Math.pow(dx, 2)+Math.pow(dy, 2))-(i.largeur/2));
		
		
				if (d<rayonMax /*&& this.ObstacleDansChampsDeVision(i)==true*/) {
					
					//Si le poissons est dans le cercle de perception on le rajoute à l'arraylist
					PredateursVus.add(i);				
				}
			}
			return(PredateursVus);
			}
		
		protected double angleOrigineAvecPoisson(Poisson poisson) {
			double alpha = 0;	//angle entre l'origine et la droite formée par les 2 poissons
			double dx = this.position[0]-poisson.position[0];	//On calcul la distance du poisson à l'autre poisson
			double dy = this.position[1]-poisson.position[1];
			if (dx<=0 && dy>=0) {	//Poisson en bas à gauche de l'obstacle
				alpha =Math.PI-Math.atan(Math.abs(dx/dy));	//On calcul alpha (dépend de la position relative)
			}
			else if (dx>=0 && dy>=0) {	//Poisson en bas à droite de l'obstacle
				alpha = Math.PI+Math.atan(Math.abs(dx/dy));
			}
			else if (dx>=0 && dy<=0) {	//Poisson en haut à droite de l'obstacle
				alpha = 2*Math.PI - Math.atan(Math.abs(dx/dy));
			}
			else if (dx<=0 && dy<=0) {	//Poisson en haut à gauche de l'obstacle
				alpha = Math.atan(Math.abs(dx/dy));
			}
			return(alpha);
		}
		
		protected double angleOrigineAvecObstacle(Obstacle obstacle) {
			double alpha = 0;	//angle entre l'origine et la droite formée par les 2 poissons
			double dx = this.position[0]-obstacle.positionCentre[0];	//On calcul la distance du poisson à l'autre poisson
			double dy = this.position[1]-obstacle.positionCentre[1];
			if (dx<=0 && dy>=0) {	//Poisson en bas à gauche de l'obstacle
				alpha =Math.PI-Math.atan(Math.abs(dx/dy));	//On calcul alpha (dépend de la position relative)
			}
			else if (dx>=0 && dy>=0) {	//Poisson en bas à droite de l'obstacle
				alpha = Math.PI+Math.atan(Math.abs(dx/dy));
			}
			else if (dx>=0 && dy<=0) {	//Poisson en haut à droite de l'obstacle
				alpha = 2*Math.PI - Math.atan(Math.abs(dx/dy));
			}
			else if (dx<=0 && dy<=0) {	//Poisson en haut à gauche de l'obstacle
				alpha = Math.atan(Math.abs(dx/dy));
			}
			return(alpha);
		}
	
// TRACER LES POISSONS AVEC LA BONNE DIRECTION

	//Permet de récuperer des coordonnées de points afin de tracer un poisson avec la bonne orientation
	protected int[] autresPoints() {
		
		double x1 = position[0] - largeur*vitesse[0]*4/7+vitesse[1]*longueur;
		double y1 = position[1] - largeur*vitesse[1]*4/7-vitesse[0]*longueur;
		
		double x2 = position[0] - largeur*vitesse[0]*4/7-vitesse[1]*longueur;
		double y2 = position[1] - largeur*vitesse[1]*4/7+vitesse[0]*longueur;
		
		double x3 = x2 - largeur*(vitesse[0])*3/7;
		double y3 = y2 - largeur*(vitesse[1])*3/7;
		
		double x4 = x1 - largeur*(vitesse[0])*3/7;
		double y4 = y1 - largeur*(vitesse[1])*3/7;
		
		int[] positions = {(int)(x1),(int)(y1),(int)(x2),(int)(y2),(int)(x3),(int)(y3),(int)(x4),(int)(y4)};
		return (positions);
	}
			

}
	
